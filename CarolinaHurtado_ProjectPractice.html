<!DOCTYPE html>
<html>
  
<head>
    <title>
        Getting pixel information
        from html canvas.
    </title>
</head>
  
<body>
    <center>
        <h1 style="color:green;">GeeksfoGeeks</h1>
          
        <h3>Getting pixel information from html CANVAS</h3>
  
        <canvas id="GFG" width="250" height="250" style="border:1px solid black;"></canvas>
  
        <script>
          Min_ColorDistance_left(255,235,244);
          /* Retrieve canvas with id GFG, and store it in a */
          var a = document.getElementById("GFG");
  
          /* Retrieve a 2D context for the canvas */
          var gfg = a.getContext("2d");
  
          var geeks = gfg.createLinearGradient(0, 0, 200, 0);
              
          geeks.addColorStop(0, "green");
          geeks.addColorStop(1, "yellow");
  
          gfg.fillStyle = geeks;
          gfg.fillRect(10, 20, 180, 180);

          var isRegion=false;

          a.addEventListener("dblclick", function(event){
            var eventCoordinates=MouseEventLocation(this,event);
            var pixelData=gfg.getImageData(eventCoordinates.x, eventCoordinates.y, 1,1).data;
            //No data values
            if ((pixelData[0]==255)&&(pixelData[1]==255)&&(pixelData[2]==255)&&(pixelData[3]==255)){
              gfg.fillStyle = "#ffffff";
              gfg.fillRect(0, 200, 250, 50);
              gfg.fillStyle = "#000000";
              gfg.fillText("NaN value",10,230);
            }
            else{
              gfg.fillStyle = "#ffffff";
              gfg.fillRect(0, 200, 250, 50);
              gfg.fillStyle = "#000000";
              ClassificationLeft(Min_ColorDistance_left(pixelData[0],pixelData[1],pixelData[2]));
            }
            })

          a.addEventListener("mousedown", function(event){
            coord_start=MouseEventLocation(this, event);
            isRegion=true;
            //console.log("down x:",coord_start.x)
            //console.log("down y:",coord_start.y)
          })
          a.addEventListener("mouseup", function(event){
            var RGB=[];
            coord_end=MouseEventLocation(this, event);
            drawRectangle(gfg, coord_start.x, coord_start.y, (coord_end.x-coord_start.x), (coord_end.y-coord_start.y))
            RGB=findPixels(gfg, coord_start.x, coord_start.y, (coord_end.x-coord_start.x), (coord_end.y-coord_start.y))
            stats(RGB[0]);
            stats(RGB[1]);
            stats(RGB[2]);
            isRegion=false;
            //console.log("up x:",coord_end.x)
            //console.log("up y:",coord_end.y)
          })

          
          //Function that decides if a pixel is in a brush region 
          function drawRectangle(canvasContext, x, y, rect_width, rect_height){
            canvasContext.beginPath();
            canvasContext.rect(x, y, rect_width, rect_height);
            canvasContext.stroke();
          }
  
          /* Define a function find(), that prints the array containing pixel information returned by the getImageData() method */
          function findPixels(canvasContext, x, y, rect_width, rect_height) {
            /* Store the pixel information of the canvas at (x,y) coordinate of (20,20) */
            var ImageData = canvasContext.getImageData(x, y, rect_width, rect_height);
            var dataLength=ImageData.data.length;
            var numberPixels=dataLength/4;
            var Red=[];
            var Green=[];
            var Blue=[];
            for(i=0; i<dataLength; i+=4){
              Red.push(ImageData.data[i]);
              Green.push(ImageData.data[i+1]);
              Blue.push(ImageData.data[i+2]);
              //console.log(i+2)
              //console.log(ImageData.data[i+2]);
            }
            //console.log(ImageData);
            //console.log(numberPixels);
            //console.log(Red);
            //console.log(Green);
            //console.log(Blue);
            //console.log([Red, Green, Blue]);
            return [Red, Green, Blue];
            }
          //Function to calculate mean and standard deviation from pixels
          function stats(array){
            var sum=0;
            var sum_Differences=0;
            for (i=0; i<array.length;i++){
              sum+=array[i];}
            //Means
            var Mean=sum/array.length;
            //std
            for(i=0; i<array.length;i++){
              sum_Differences+=(array[i]-Mean);
            }
            var Std=sum_Differences/array.length;
            console.log("Mean:",Mean)
            console.log("std:",Std)
          }
            
        //Function to find the closest color using the classes from QGIS - image left
        function Min_ColorDistance_left(R,G,B){
          var df=[178, 24, 44, 236, 132, 95, 250, 202, 178, 255, 242, 174, 235, 244, 213, 179, 212, 231, 89, 156, 200,33, 102, 172];
          var distances=[];
          for(i=0; i<df.length;i+=3){
            distances.push(Math.sqrt(((R-df[i])*(R-df[i]))+((G-df[i+1])*(G-df[i+1]))+((B-df[i+2])*(B-df[i+2]))));
          }
          //console.log(distances)
          var closest_distance=Math.min(...distances);
          var closest_index=distances.indexOf(closest_distance);
          //console.log(closest_distance);
          //console.log(closest_index);
          return closest_index;

        }

        //Function to classify pixel on change ranges
        function ClassificationLeft(index_min_left){
          if (index_min_left==0){gfg.fillText("Subsidence between -1 to -0.75 m",10,230);}
          else if (index_min_left==1){gfg.fillText("Subsidence between -0.75 to -0.5 m",10,230);}
          else if (index_min_left==2){gfg.fillText("Subsidence between -0.5 to -0.25 m",10,230);}
          else if (index_min_left==3){gfg.fillText("Subsidence between -0.25 to 0 m",10,230);}
          else if (index_min_left==4){gfg.fillText("Uplifting between 0 to 0.25 m",10,230);}
          else if (index_min_left==5){gfg.fillText("Uplifting between 0.25 to 0.5 m",10,230);}
          else if (index_min_left==6){gfg.fillText("Uplifting between 0.5 to 0.75 m",10,230);}
          else if (index_min_left==7){gfg.fillText("Uplifting between 0.75 to 1 m",10,230);}
        }
          //Function to return of an object (canvas) in the document
        function CanvasPosition(obj){
            var horizontal=0
            var vertical=0
            if(obj.offsetParent){
                do{
                    horizontal+=obj.offsetLeft;
                    vertical+=obj.offsetTop;
                }while (obj=obj.offsetParent);
                return {x:horizontal, y:vertical};
            }
            return undefined;
        }

        //Function to locate mouse event on canvas
        function MouseEventLocation(object, event){
            var position=CanvasPosition(object);
            return{
                x:(event.pageX-position.x), y:(event.pageY-position.y)
            };
        }
  
        </script>
    </center>
</body>
  
</html>